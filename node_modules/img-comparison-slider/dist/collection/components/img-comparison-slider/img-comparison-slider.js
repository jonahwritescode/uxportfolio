import { Component, h, Listen, Element } from '@stencil/core';
import { inBetween } from '../../utils/inBetween';
const getTouchPagePoint = (e) => ({
  x: e.touches[0].pageX,
  y: e.touches[0].pageY,
});
const KeySlideOffset = {
  ArrowLeft: -1,
  ArrowRight: 1,
};
export class ImgComparisonSlider {
  constructor() {
    this.exposure = 50;
    this.isMouseDown = false;
    this.isFocused = false;
    this.isTouchComparing = false;
    this.hasTouchMoved = false;
  }
  componentWillLoad() {
    this.el.querySelectorAll('img').forEach((img) => {
      img.addEventListener('dragstart', (e) => {
        e.preventDefault();
      });
      img.addEventListener('load', () => {
        this.updateAfterWidth();
      });
    });
  }
  componentDidRender() {
    this.slide(0);
    this.updateAfterWidth();
    this.el.setAttribute('tabindex', '0');
  }
  disconnectedCallback() {
    if (this.transitionTimer) {
      window.clearTimeout(this.transitionTimer);
    }
  }
  slide(increment = 0, transition = false) {
    this.exposure = inBetween(this.exposure + increment, 0, 100);
    if (transition) {
      const transitionTime = 100;
      this.after.style.transition = `width ${transitionTime}ms`;
      this.transitionTimer = window.setTimeout(() => {
        this.after.style.transition = null;
        this.transitionTimer = null;
      }, transitionTime);
    }
    this.after.style.width = `${this.exposure}%`;
  }
  onKeyDown(e) {
    if (this.keyboardSlideAnimationTimeoutId) {
      return;
    }
    const key = e.key;
    if (!Object.keys(KeySlideOffset).includes(key)) {
      return;
    }
    this.startSlideAnimation(KeySlideOffset[key]);
  }
  onKeyUp(e) {
    if (!this.keyboardSlideAnimationTimeoutId) {
      return;
    }
    if (!Object.keys(KeySlideOffset).includes(e.key)) {
      return;
    }
    this.stopSlideAnimation();
  }
  onMouseDown(e) {
    this.isMouseDown = true;
    this.slideToPageX(e.pageX, true);
    this.el.focus();
  }
  onMouseUp(e) {
    this.isMouseDown = false;
  }
  onMouseMove(e) {
    if (this.isMouseDown) {
      this.slideToPageX(e.pageX);
    }
  }
  onTouchStart(e) {
    this.touchStartPoint = getTouchPagePoint(e);
    if (this.isFocused) {
      this.slideToPageX(e.touches[0].pageX, true);
    }
  }
  onTouchMove(e) {
    if (this.isTouchComparing) {
      this.slideToPageX(e.touches[0].pageX);
      e.preventDefault();
      return false;
    }
    if (!this.hasTouchMoved) {
      const currentPoint = getTouchPagePoint(e);
      if (Math.abs(currentPoint.y - this.touchStartPoint.y) <
        Math.abs(currentPoint.x - this.touchStartPoint.x)) {
        this.isTouchComparing = true;
        this.el.focus();
        this.slideToPageX(e.touches[0].pageX, true);
        e.preventDefault();
        return false;
      }
      this.hasTouchMoved = true;
    }
  }
  touchEnd() {
    this.isTouchComparing = false;
    this.hasTouchMoved = false;
  }
  onBlur() {
    this.stopSlideAnimation();
    this.isFocused = false;
  }
  onFocus() {
    this.isFocused = true;
  }
  updateAfterWidth() {
    this.imageWidth = this.el.offsetWidth;
    this.afterImageContainer.style.width = `${this.el.offsetWidth}px`;
  }
  slideToPageX(pageX, transition = false) {
    const x = pageX - this.el.getBoundingClientRect().left - window.scrollX;
    this.exposure = (x / this.imageWidth) * 100;
    this.slide(0, transition);
  }
  startSlideAnimation(offset) {
    const fps = 120;
    const fraction = 1 * offset;
    const slide = () => {
      this.keyboardSlideAnimationTimeoutId = window.setTimeout(() => {
        this.animationRequestId = window.requestAnimationFrame(slide);
      }, 1000 / fps);
      this.slide(fraction);
    };
    slide();
  }
  stopSlideAnimation() {
    if (!this.keyboardSlideAnimationTimeoutId) {
      return;
    }
    window.clearTimeout(this.keyboardSlideAnimationTimeoutId);
    window.cancelAnimationFrame(this.animationRequestId);
    this.keyboardSlideAnimationTimeoutId = null;
    this.animationRequestId = null;
  }
  render() {
    return (h("div", null,
      h("div", { class: "before", ref: (el) => (this.before = el) },
        h("slot", { name: "before" })),
      h("div", { class: "after", ref: (el) => (this.after = el) },
        h("div", { class: "handle-wrapper" },
          h("slot", { name: "handle" },
            h("div", { class: "handle" }))),
        h("div", { class: "after-overlay" },
          h("div", { ref: (el) => (this.afterImageContainer = el) },
            h("slot", { name: "after" }))))));
  }
  static get is() { return "img-comparison-slider"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["img-comparison-slider.scss"]
  }; }
  static get styleUrls() { return {
    "$": ["img-comparison-slider.css"]
  }; }
  static get elementRef() { return "el"; }
  static get listeners() { return [{
      "name": "keydown",
      "method": "onKeyDown",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "keyup",
      "method": "onKeyUp",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "mousedown",
      "method": "onMouseDown",
      "target": undefined,
      "capture": false,
      "passive": true
    }, {
      "name": "mouseup",
      "method": "onMouseUp",
      "target": "window",
      "capture": false,
      "passive": true
    }, {
      "name": "mousemove",
      "method": "onMouseMove",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "touchstart",
      "method": "onTouchStart",
      "target": undefined,
      "capture": false,
      "passive": true
    }, {
      "name": "touchmove",
      "method": "onTouchMove",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "touchend",
      "method": "touchEnd",
      "target": undefined,
      "capture": false,
      "passive": true
    }, {
      "name": "blur",
      "method": "onBlur",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "focus",
      "method": "onFocus",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "resize",
      "method": "updateAfterWidth",
      "target": "window",
      "capture": false,
      "passive": true
    }]; }
}
