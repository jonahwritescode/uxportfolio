import { r as registerInstance, h, g as getElement } from './index-6a8d4a1b.js';

const inBetween = (actual, min, max) => {
  if (actual < min) {
    return min;
  }
  if (actual > max) {
    return max;
  }
  return actual;
};

const imgComparisonSliderCss = ":host{--divider-width:1px;--divider-color:#d7d7d7;--handle-size:40px;--handle-color:#d7d7d7;--handle-opacity:0.5;--handle-opacity-active:0;position:relative;display:inline-block;font-size:0;overflow:hidden;isolation:isolate;line-height:0}:host(:focus) .handle-wrapper{opacity:var(--handle-opacity-active)}::slotted(img){-webkit-user-drag:none;-khtml-user-drag:none;-moz-user-drag:none;-o-user-drag:none;user-drag:none;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.before{position:relative;z-index:-2}.after{position:absolute;left:0;top:0;bottom:0;z-index:-1}.after .after-overlay{overflow:hidden}.after:before{content:\" \";position:absolute;display:block;right:calc(var(--divider-width) * -0.5);top:0;bottom:0;border-right-width:var(--divider-width);border-right-style:solid;border-right-color:var(--divider-color)}.handle-wrapper{position:absolute;width:var(--handle-size);height:var(--handle-size);margin-top:calc(var(--handle-size) / (-2));margin-right:calc(var(--handle-size) / (-2));top:50%;right:0;pointer-events:none;-webkit-box-sizing:border-box;box-sizing:border-box;opacity:var(--handle-opacity);-webkit-transition:opacity 1s;transition:opacity 1s}.handle{background-color:var(--handle-color);width:var(--handle-size);height:var(--handle-size);-webkit-transition:-webkit-transform 1s;transition:-webkit-transform 1s;transition:transform 1s;transition:transform 1s, -webkit-transform 1s;-webkit-transform:rotate(45deg);transform:rotate(45deg);-webkit-box-shadow:0px 0px 15px 0px rgba(0, 0, 0, 0.75);box-shadow:0px 0px 15px 0px rgba(0, 0, 0, 0.75)}.focused .handle{-webkit-transform:rotate(45deg) scale(1.5);transform:rotate(45deg) scale(1.5)}";

const getTouchPagePoint = (e) => ({
  x: e.touches[0].pageX,
  y: e.touches[0].pageY,
});
const KeySlideOffset = {
  ArrowLeft: -1,
  ArrowRight: 1,
};
const ImgComparisonSlider = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.exposure = 50;
    this.isMouseDown = false;
    this.isFocused = false;
    this.isTouchComparing = false;
    this.hasTouchMoved = false;
  }
  componentWillLoad() {
    this.el.querySelectorAll('img').forEach((img) => {
      img.addEventListener('dragstart', (e) => {
        e.preventDefault();
      });
      img.addEventListener('load', () => {
        this.updateAfterWidth();
      });
    });
  }
  componentDidRender() {
    this.slide(0);
    this.updateAfterWidth();
    this.el.setAttribute('tabindex', '0');
  }
  disconnectedCallback() {
    if (this.transitionTimer) {
      window.clearTimeout(this.transitionTimer);
    }
  }
  slide(increment = 0, transition = false) {
    this.exposure = inBetween(this.exposure + increment, 0, 100);
    if (transition) {
      const transitionTime = 100;
      this.after.style.transition = `width ${transitionTime}ms`;
      this.transitionTimer = window.setTimeout(() => {
        this.after.style.transition = null;
        this.transitionTimer = null;
      }, transitionTime);
    }
    this.after.style.width = `${this.exposure}%`;
  }
  onKeyDown(e) {
    if (this.keyboardSlideAnimationTimeoutId) {
      return;
    }
    const key = e.key;
    if (!Object.keys(KeySlideOffset).includes(key)) {
      return;
    }
    this.startSlideAnimation(KeySlideOffset[key]);
  }
  onKeyUp(e) {
    if (!this.keyboardSlideAnimationTimeoutId) {
      return;
    }
    if (!Object.keys(KeySlideOffset).includes(e.key)) {
      return;
    }
    this.stopSlideAnimation();
  }
  onMouseDown(e) {
    this.isMouseDown = true;
    this.slideToPageX(e.pageX, true);
    this.el.focus();
  }
  onMouseUp(e) {
    this.isMouseDown = false;
  }
  onMouseMove(e) {
    if (this.isMouseDown) {
      this.slideToPageX(e.pageX);
    }
  }
  onTouchStart(e) {
    this.touchStartPoint = getTouchPagePoint(e);
    if (this.isFocused) {
      this.slideToPageX(e.touches[0].pageX, true);
    }
  }
  onTouchMove(e) {
    if (this.isTouchComparing) {
      this.slideToPageX(e.touches[0].pageX);
      e.preventDefault();
      return false;
    }
    if (!this.hasTouchMoved) {
      const currentPoint = getTouchPagePoint(e);
      if (Math.abs(currentPoint.y - this.touchStartPoint.y) <
        Math.abs(currentPoint.x - this.touchStartPoint.x)) {
        this.isTouchComparing = true;
        this.el.focus();
        this.slideToPageX(e.touches[0].pageX, true);
        e.preventDefault();
        return false;
      }
      this.hasTouchMoved = true;
    }
  }
  touchEnd() {
    this.isTouchComparing = false;
    this.hasTouchMoved = false;
  }
  onBlur() {
    this.stopSlideAnimation();
    this.isFocused = false;
  }
  onFocus() {
    this.isFocused = true;
  }
  updateAfterWidth() {
    this.imageWidth = this.el.offsetWidth;
    this.afterImageContainer.style.width = `${this.el.offsetWidth}px`;
  }
  slideToPageX(pageX, transition = false) {
    const x = pageX - this.el.getBoundingClientRect().left - window.scrollX;
    this.exposure = (x / this.imageWidth) * 100;
    this.slide(0, transition);
  }
  startSlideAnimation(offset) {
    const fps = 120;
    const fraction = 1 * offset;
    const slide = () => {
      this.keyboardSlideAnimationTimeoutId = window.setTimeout(() => {
        this.animationRequestId = window.requestAnimationFrame(slide);
      }, 1000 / fps);
      this.slide(fraction);
    };
    slide();
  }
  stopSlideAnimation() {
    if (!this.keyboardSlideAnimationTimeoutId) {
      return;
    }
    window.clearTimeout(this.keyboardSlideAnimationTimeoutId);
    window.cancelAnimationFrame(this.animationRequestId);
    this.keyboardSlideAnimationTimeoutId = null;
    this.animationRequestId = null;
  }
  render() {
    return (h("div", null, h("div", { class: "before", ref: (el) => (this.before = el) }, h("slot", { name: "before" })), h("div", { class: "after", ref: (el) => (this.after = el) }, h("div", { class: "handle-wrapper" }, h("slot", { name: "handle" }, h("div", { class: "handle" }))), h("div", { class: "after-overlay" }, h("div", { ref: (el) => (this.afterImageContainer = el) }, h("slot", { name: "after" }))))));
  }
  get el() { return getElement(this); }
};
ImgComparisonSlider.style = imgComparisonSliderCss;

export { ImgComparisonSlider as img_comparison_slider };
